### 1. `constructor()`

- 모든 뷰는 **생성자에 의해 생명 주기가 시작**됨 (AttributeSet 을 갖게 됨)
- `addView()` 메소드를 갖게 됨

### 2. `onAttachedToWindow()`

- **부모 뷰가 `addView()` 를 호출**함으로써 **`View` 가 윈도우에 붙을 때 호출**된다 (말 그대로)
- **고유 ID 를 통해 `View` 에 접근 가능**해짐
- 이 순간부터는 **뷰를 그리기 위한 `surface`** 를 가짐
    - 단, `onDetachedFromWindow()` 호출 이후에는 `surface` 가 없음액티비티 `onDestroyed()` 호출될 때, 혹은 부모 뷰에서 해당 뷰를 제거할 때 호출
- 따라서 이 순간부터는 **리소스 할당 및 리스너 설정 등이 가능**해짐

### 3. `onMeasure()`

- `measure()` 에서 호출하는 콜백 메소드 **(`View` 의 크기를 측정하기 위해 호출됨)**
    - **부모 뷰**의 경우에는 **모든 자식 뷰들의 `measure()` 를 호출한 뒤 자신의 크기 결정**
    - **`setMeasuredDimenstion()` 호출하여 명시적으로 너비와 높이 설정**
1.  **`onLayout()`**
- **`layout()` 에서 호출하는 콜백 메소드 (뷰의 크기와 위치 지정)**
- 즉, 뷰의 **크기와 위치를 지정하여 화면에 배치한 후에 호출**함 (주로 부모 뷰일 때 호출)
- 아직 **뷰가 그려지는 단계는 아님** (헷갈리지 말자!)

### 5. `dispatchToDraw()`

- `ViewGroup` 에 속한 메소드
- 뷰가 다시 그려져야 할 경우에 자식 뷰들도 싹 다 다시 그려지도록 함

### 6. `onDraw()`

- **실제로 뷰를 그리는 단계**
    - **`Canvas`** : **뷰의 모양**을 그리는 객체
    - **`Paint`** : **뷰의 색상**을 칠하는 객체
- **크기와 위치는 이전에 계산**되기 때문에 그것들을 **기준으로 뷰를 그리게** 됨
- **해당 콜백 메소드는 언제든 다시 호출될 수 있기 때문에, 이 안에서 객체 생성은 하면 안 됨**
    - 스크롤, 스와이프 등 인터랙션이 발생하면 언제든 호출될 수 있음
    
    ### 6-1. `invalidate()`
    
    - 글자나 색상 등 크기 변화는 없이 **단순히 뷰의 속성 등이 변경되어 다시 그려야하는 경우 `View` 를 다시 그리기 위해 호출하는 메소드**
    
    ### 6-2. `requestLayout()`
    
    - 위에서 크기 변화 없이라고 했는데, **만약 뷰의 크기 변화가 발생할 경우** 레이아웃의 배치도 달라질 수 있기 때문에 해당 메소드를 호출함으로써 **뷰들의 크기 측정부터 다시**하게 됨
