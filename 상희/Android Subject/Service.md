# 💡 Service

# ✅ Service
Service는 백그라운드에서 오래 실행되는 작업을 수행할 수 있는 애플리케이션 구성 요소이며 사용자 인터페이스를 제공하지 않는다.  
다른 애플리케이션 구성 요소가 서비스를 시작할 수 있으며 이는 사용자가 다른 애플리케이션으로 전환하더라도 백그라운드에서 계속해서 실행된다.  
이외에도 구성 요소를 서비스에 바인딩하여 서비스와 상호 작용할 수 있으며 심지어는 프로세스 간 통신(IPC)도 수행할 수 있다.  
예를 들어 한 서비스는 네트워크 트랜잭션을 처리하고, 음악을 재생하고 파일 I/O를 수행하거나 콘텐츠 제공자와 상호 작용할 수 있으며 이 모든 것을 백그라운드에서 수행할 수 있다.

<br/>

## 서비스의 유형
서비스에는 세 가지 유형이 있다.

<br/>

### 포그라운드(Foreground)
포그라운드 서비스는 사용자에게 잘 보이는 몇몇 작업을 수행한다.  
예를 들어 오디오 앱이라면 오디오 트랙을 재생할 때 포그라운드 서비스를 사용한다.  
포그라운드 서비스는 알림을 표시해야 한다.  
포그라운드 서비스는 사용자가 앱과 상호 작용하지 않을 때도 계속 실행된다.

<br/>

### 백그라운드(Background)
백그라운드 서비스는 사용자에게 직접 보이지 않는 작업을 수행한다.  
예컨대 어느 앱이 저장소를 압축하는 데 서비스를 사용했다면 이것은 대개 백그라운드 서비스이다.

> 앱이 API 레벨 26 이상을 대상으로 한다면 앱이 포그라운드에 있지 않을 때 시스템에서 백그라운드 서비스 실행에 대한 제한을 적용한다. 이와 같은 경우에서는 대부분 앱이 예약된 작업을 사용해야 합니다.
> 

<br/>

### 바인드(Bound)
애플리케이션 구성 요소가 bindService()를 호출하여 해당 서비스에 바인딩되면 서비스가 바인딩된다.  
바인딩된 서비스는 클라이언트-서버 인터페이스를 제공하여 구성 요소가 서비스와 상호 작용하게 하며 결과를 받을 수도 있고, 심지어 이와 같은 작업을 여러 프로세스에 걸쳐 프로세스 간 통신(IPC)으로 수행할 수도 있다.  
바인딩된 서비스는 또 다른 애플리케이션 구성 요소가 이에 바인딩되어 있는 경우에만 실행된다.  
여러 개의 구성 요소가 서비스에 한꺼번에 바인딩될 수 있지만, 이 모든 것에서 바인딩이 해제되면 해당 서비스는 소멸된다.

<br/>

서비스는 시작된 서비스와 바인딩된 서비스 양쪽 방식으로 둘 다 작동할 수 있다.  
즉, (무한히 실행되도록) 시작할 수도 있고, 바인딩도 허용할 수 있다.  
이것은 단순히 몇 가지 콜백 메서드를 구현했는지 여부에 좌우되는 문제이다.

> 구성 요소가 서비스를 시작하게 하는 onStartCommand()와 바인딩을 허용하는 onBind()
> 

<br/>

서비스가 시작되었는지, 바인딩되었는지, 또는 두 가지 모두에 관계없이 애플리케이션 구성 요소는 Intent로 시작하여 구성 요소가 액티비티를 사용할 수 있는 것과 동일한 방식으로 서비스를 사용할 수 있다. (심지어 별도의 애플리케이션에서도)  
그러나 매니페스트에서 서비스를 비공개로 선언하고 다른 애플리케이션으로부터의 액세스를 차단할 수도 있다. 

<br/>

> 서비스는 자신의 호스팅 프로세스의 기본 스레드에서 실행된다.  
> 서비스는 자신의 스레드를 직접 생성하지 않으며, 별도의 프로세스에서 실행되지도 않는다(별도로 지정하는 경우는 예외).  
> 서비스가 CPU 집약적인 작업을 수행할 예정이거나 차단 작업을 수행할 예정인 경우(예를 들어 MP3 재생 또는 네트워킹 등), 서비스 내에 새 스레드를 생성하여 해당 작업을 수행하도록 해야 한다.  
> 별도의 스레드를 사용하면 '애플리케이션이 응답하지 않습니다(ANR)' 오류가 일어날 위험을 줄일 수 있으며 애플리케이션의 기본 스레드는 액티비티와 사용자 상호 작용 전용으로 유지될 수 있다.
> 

<br/>

## 서비스와 스레드 간의 선택
서비스는 그저 백그라운드에서 실행될 수 있는 구성 요소일 뿐이다.  
이는 사용자가 애플리케이션과 상호 작용하지 않아도 관계없이 해당된다.  
그러므로 필요한 경우에만 서비스를 사용해야 한다.

<br/>

사용자가 애플리케이션과 상호 작용하는 동안 기본 스레드 밖에서 작업을 수행해야 하는 경우, 새 스레드를 생성해야 한다.  
예를 들어 액티비티가 실행되는 중에만 음악을 재생하고자 하는 경우, onCreate() 안에 스레드를 생성하고 이를 onStart()에서 실행하기 시작한 다음, onStop()에서 중단하면 된다.  
또한 기존의 Thread 클래스 대신 `java.util.concurrent`의 thread pool과 executors 또는 Kotlin coroutines를 사용해 보는 것도 고려하면 좋다.

> 자세한 내용 참조  
> : [Background Work Overview  |  Android Developers](https://developer.android.com/guide/background)
> 

<br/>

서비스를 사용하는 경우 기본적으로 애플리케이션의 기본 스레드에서 계속 실행되므로 서비스가 집약적이거나 차단 작업을 수행하는 경우 여전히 서비스 내에 새 스레드를 생성해야 한다는 점을 명심해야 한다.

<br/>

## 기본 사항
서비스를 생성하려면 `Service`의 하위 클래스(또는 이것의 기존 하위 클래스 중 하나)를 생성해야 한다.  
구현에서는 서비스 수명 주기의 주요 측면을 처리하는 콜백 메서드를 몇 가지 재정의해야 하며 서비스에 바인딩할 구성 요소에 대한 메커니즘을 제공해야 한다(해당되는 경우).  
다음은 재정의가 필요한 가장 중요한 콜백 메서드이다.

<br/>

### onStartCommand()
시스템이 이 메서드를 호출하는 것은 또 다른 구성 요소(예 : 액티비티)가 서비스를 시작하도록 요청하는 경우이다.  
이때 `startService()`를 호출하는 방법을 쓴다.  
이 메서드가 실행되면 서비스가 시작되고 백그라운드에서 무한히 실행될 수 있다.  
이것을 구현하면 서비스의 작업이 완료되었을 때 해당 서비스를 중단하는 것은 개발자 본인의 책임이며, 이때 `stopSelf()` 또는 `stopService()`를 호출하면 된다.  
바인딩만 제공하고자 하는 경우, 이 메서드를 구현하지 않아도 된다.

<br/>

### onBind()
시스템은 다른 구성 요소가 해당 서비스에 바인딩되고자 하는 경우(예를 들어 RPC를 수행하기 위해)에도 이 메서드를 호출한다.  
이때 `bindService()`를 호출하는 방법을 사용한다.  
이 메서드를 구현할 때에는 클라이언트가 서비스와 통신을 주고받기 위해 사용할 인터페이스를 제공해야 한다. 이때 `IBinder`를 반환하면 된다.  
이 메서드는 항상 구현해야 하지만, 바인딩을 허용하지 않으려면 null을 반환해야 한다.

<br/>

### onCreate()
시스템은 서비스가 처음 생성되었을 때(즉, 서비스가 `onStartCommand()` 또는 `onBind()`를 호출하기 전에) 이 메서드를 호출하여 일회성 설정 절차를 수행한다.  
서비스가 이미 실행 중인 경우, 이 메서드는 호출되지 않는다.

<br/>

### onDestroy()
시스템이 이 메서드를 호출하는 것은 서비스를 더 이상 사용하지 않고 소멸시킬 때이다.  
서비스는 스레드, 등록된 리스너 또는 수신기 등의 각종 리소스를 정리하기 위해 이것을 구현해야 한다.  
이는 서비스가 수신하는 마지막 호출이다.  

<br/>

한 구성 요소가 `startService()`를 호출하여 서비스를 시작하면(`onStartCommand()`에 대한 호출 발생), 해당 서비스는 알아서 `stopSelf()`로 스스로 중단할 때까지 또는 다른 구성 요소가 `stopService()`를 호출하여 서비스를 중단시킬 때까지 실행 중인 상태로 유지된다.  

<br/>

한 구성 요소가 `bindService()`를 호출하여 서비스를 생성하는 경우(그리고 `onStartCommand()`를 호출하지 않은 경우), 해당 서비스는 해당 구성 요소가 바인딩된 경우에만 실행된다. 서비스가 모든 클라이언트로부터 바인딩이 해제되면 시스템이 이를 소멸시킵니다.

<br/>

Android 시스템이 서비스를 강제 중단하는 것은 메모리가 부족하여 사용자 포커스를 가진 액티비티를 위해 시스템 리소스를 회복해야만 하는 경우로만 국한된다.  
서비스가 사용자 포커스를 가진 액티비티에 바인딩된 경우 종료될 가능성이 적고, 서비스가 [포그라운드에서 실행](https://developer.android.com/guide/components/services?hl=ko#Foreground)되도록 선언된 경우에는 종료될 가능성이 희박하다.  
서비스가 시작되어 장시간 실행 중이라면 시스템은 시간이 지나면서 백그라운드 작업 목록에서 이 서비스가 차지하는 위치를 낮추고, 따라서 서비스가 종료될 가능성이 높아진다.  
서비스가 시작되었다면 시스템에 의한 재시작을 정상적으로 처리하도록 설계해야 한다.  
시스템이 서비스를 중단하는 경우, 리소스를 다시 사용할 수 있게 되면 가능한 한 빨리 서비스가 다시 시작됩니다. 다만 개발자가 `onStartCommand()`에서 반환하는 값에 따라 달라진다.  
시스템이 서비스를 소멸시킬 수 있는 경우에 대한 자세한 내용은 [프로세스와 스레드](https://developer.android.com/guide/components/processes-and-threads?hl=ko) 문서를 참조하면 된다.

<br/>

### 매니페스트에서 서비스 선언
액티비티 및 다른 구성 요소와 마찬가지로, 서비스는 모두 애플리케이션의 매니페스트 파일에서 선언해야 한다.  
서비스를 선언하려면 `<service>` 요소를 `<application>` 요소의 하위로 추가하면 됩니다. 다음은 이에 대한 예이다.

```xml
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
```

<br/>

매니페스트에서 서비스를 선언하는 방법에 대한 자세한 내용은 `<service>` 요소 참조 문서를 확인하면 된다.  
`<service>` 요소에 포함할 수 있는 다른 특성도 있다.   
이 요소를 포함하여 서비스를 시작하는 데 필요한 권한과 서비스를 실행해야 하는 프로세스 등의 특성을 정의할 수 있다.  
`android:name` 특성이 유일한 필수 특성이다. 이는 서비스의 클래스 이름을 나타낸다.  
애플리케이션을 게시한 후에는 이 이름을 그대로 두어야 서비스를 시작 또는 바인딩할 명시적 인텐트에 대한 종속성 때문에 코드가 깨질 위험을 막을 수 있다. (블로그 게시물 [변경할 수 없는 것](http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html) 참조)

<br/>

> **주의**  
> : 앱의 보안을 지키기 위해서는 **`Service`** 를 시작할 때에는 항상 명시적 인텐트만 사용하고 서비스에 대한 인텐트 필터는 선언하지 말아야 한다.  
> 암시적 인텐트를 사용하여 서비스를 시작하면 보안 위험을 초래한다.  
> 인텐트에 어느 서비스가 응답할 것인지 확신할 수 없고, 사용자는 어느 서비스가 시작되는지 볼 수 없기 때문이다.  
> Android 5.0(API 레벨 21)부터 시스템은 개발자가 암시적 인텐트로 **`bindService()`** 를 호출하면 예외를 발생시킨다.
> 

<br/>

`android:exported` 특성을 포함하고 이를 `false`로 설정하면 서비스를 본인의 앱에만 사용 가능하게 할 수 있다. 이렇게 하면 다른 앱이 서비스를 시작하지 못하도록 효과적으로 방지하며 이는 명시적 인텐트를 사용하는 경우에도 문제 없이 적용된다.

<br/>

> **참고**  
> : 사용자는 기기에서 어떤 서비스가 실행되는지 볼 수 있다.  
> 정체를 모르거나 신뢰할 수 없는 서비스를 보면 사용자가 서비스를 중단할 수 있다.  
> 사용자에 의해 우발적으로 서비스가 중단되는 불상사를 막으려면 앱 매니페스트의 **`<service>`** 요소에 **`android:description`** 특성을 추가해야 한다.  
> Description에 서비스가 하는 일과 서비스의 장점을 설명하는 간략한 문장을 기재하면 된다.
> 

<br/>
<br/>

# 🗂 참고
- [서비스 개요  |  Android 개발자  |  Android Developers](https://developer.android.com/guide/components/services?hl=ko)
- [Services overview  |  Android Developers](https://developer.android.com/guide/components/services)
