# 💡 Coroutines

# ✅ Coroutine
코루틴(Coroutine)은 파이썬, C#, Go, Javascript 등 여러 언어에서 지원하고 있는 개념이다. Kotlin만의 것이 아니다.  
JavaScript를 사용하고 있으면서 async await를 사용하고 있다면 이미 코루틴을 사용해본 경험이 있는 것이다. 아무튼 코루틴은 새로운 개념, 새로운 기술이 아니라 프로그래밍이 세상에 나온 초창기부터 존재하던 개념이다.

<br/>

## Kotlin Coroutine을 공부해야 하는 이유
앱이든 웹이든 비동기 처리가 핵심인 클라이언트 프로그래밍에서 지금까지 가장 핫한 키워드는 rx programming일 것이다. 그러나 구글이 안드로이드 공식 언어를 자바에서 코틀린으로 변경한 이후, 최근 들어 대표적인 샘플 예제들인 bluprint와 sunflower 앱의 비동기 처리를 coroutine으로 바꾸었다. (아직 rx로 짠 코드를 특정 브랜치로 남겨 놓고 있긴 하다). Rx 라이브러리를 걷어내고 코루틴으로 새로 작성한 것이다.  
이와 더불어 상당히 많은 외국 자료들이 올라오고 있다. 그 이유는 코루틴을 사용하면 비동기 처리가 너무나도 쉽게 이루어 질 수 있기 때문이라고 생각한다. 이런 이유 만으로 코루틴을 공부해 볼 가치는 충분하다.

<br/>

## Coroutine이란?
### Coroutine Keyword
1. **협력형 멀티 태스킹**
2. 동시성 프로그래밍 지원
3. 비동기 처리를 쉽게 도와 줌

<br/>

### 협력형 멀티 태스킹
협력형 멀티태스킹을 프로그래밍 언어로 표현하자면 Co + Routine 이다.  
**Co**라는 접두어는 “협력”, “함께”라는 의미를 지니고 있다.  
**Routine**은 하나의 태스크, 함수 정도로 생각하면 된다.  
즉, 협력하는 함수다.

<br/>

#### Routine
Routine에는 우리가 흔히 알고 있는 Main Routine과 Sub Routine이 존재한다. 이런 단어들이 생소할 수도 있지만, 우리가 늘 작성하고 있는 코드들이다.

<br/>

![https://user-images.githubusercontent.com/18481078/63651600-6a5a5100-c791-11e9-87d1-3f81dc9b415d.png](https://user-images.githubusercontent.com/18481078/63651600-6a5a5100-c791-11e9-87d1-3f81dc9b415d.png)

위의 코드를 보면 main 함수가 메인이 되는 함수다. 메인이 되는 함수는 서브 함수인 plusOne을 호출한다. 우리가 짜는 프로그램은 흔히 이렇게 되어 있다.

<br/>

##### Sub Routine

![https://user-images.githubusercontent.com/18481078/63651648-f8ced280-c791-11e9-9917-1b034b855e84.png](https://user-images.githubusercontent.com/18481078/63651648-f8ced280-c791-11e9-9917-1b034b855e84.png)

Sub Routine은 루틴에 진입하는 지점과 루틴을 빠져나오는 지점이 명확하다.  
즉, 메인 루틴이 서브 루틴을 호출하면 서브 루틴의 맨 처음 부분에 진입하여 `return` 문을 만나거나 서브 루틴의 닫는 괄호를 만나면 해당 서브 루틴을 빠져나오게 된다.

<br/>

![https://user-images.githubusercontent.com/18481078/63651659-303d7f00-c792-11e9-9aae-0b756bb5e8a8.png](https://user-images.githubusercontent.com/18481078/63651659-303d7f00-c792-11e9-9aae-0b756bb5e8a8.png)

메인 스레드가 `plusOne`이라는 서브 루틴에 진입한다. 당연히 코드는 처음부터 진입이 되어 맨 위 줄부터 실행이 될 것이고, 그 아래 코드들을 쭉쭉 실행해서 `return` 문을 만나면 서브 루틴을 호출했던 부분으로 탈출한다. 그리고 진입점과 탈출점 사이에 스레드는 블락되어 있다.  

<br/>

그러나 코루틴(Coroutine)은 조금 다르다.

![https://user-images.githubusercontent.com/18481078/63651705-a0e49b80-c792-11e9-9924-eb737b813065.png](https://user-images.githubusercontent.com/18481078/63651705-a0e49b80-c792-11e9-9924-eb737b813065.png)

코루틴도 routine이기 때문에 하나의 함수로 생각하면 된다. 그런데 이 함수에 진입할 수 있는 진입점도 여러 개고, 함수를 빠져나갈 수 있는 탈출점도 여러 개다.  
즉, 코루틴 함수는 꼭 return 문이나 마지막 닫는 괄호를 만나지 않더라도 언제든지 중간에 나갈 수 있고, 언제든지 다시 나갔던 그 지점으로 들어올 수 있다.

<br/>

```kotlin
fun drawPerson() {
    startCoroutine {
        drawHead()
        drawBody()
        drawLegs()
    }
}

suspend fun drawHead() {
    delay(2000)
    ...
}

suspend fun drawBody() {
    delay(5000)
    ...
}

suspend fun drawLegs() {
    delay(3000)
    ...
}
```

drawPerson이라는 함수가 있다. 이 함수 안에는 startCoroutine이라는 코루틴 빌더가 있다(실제로 startCoroutine이라는 빌더는 존재하지 않는다. 실제 코루틴 라이브러리에는 다른 방식으로 코루틴을 만들지만, 여기에서는 이해를 위해 쉽게 startCoroutine이라고 사용한다.)  
startCoroutine이라는 코루틴을 만나게 되면 해당 함수는 코루틴으로 작동할 수 있다. 따라서 언제든 함수 실행 중간에 나갈 수도 있고, 다시 들어올 수도 있는 자격이 부여되는 것이다.  
언제 코루틴을 중간에 나갈수 있을까? suspend로 선언된 함수를 만나면 코루틴 밖으로 잠시 나갈 수 있다.

<br/>

1. 스레드의 Main함수가 `drawPerson()`을 호출하면 `startCoroutine`블럭을 만나 코루틴이 된다. (정확하게는 하나의 코루틴을 만들어 시작한다). 위에도 말했듯이 이제 `drawPerson()`은 진입점과 탈출점이 여러 개가 되는 자격이 주어진 것이다.
2. 코루틴이 실행이 되었지만, `suspend`를 만나기 전까지는 그다지 특별한 힘이 없다. `suspend`로 정의된 함수가 없다면 그냥 마지막 괄호를 만날 때 까지 계속 실행된다. 그러나 `drawHead()`는 `suspend` 키워드로 정의되어진 함수다. 따라서 `drawHead()` 부분에서 더 이상 아래 코드를 실행하지 않고 `drawPerson()`이라는 코루틴 함수를 (잠시) 탈출한다.
3. 메인 스레드가 해당 코루틴을 탈출했다. 그렇다고 스레드가 놀고 있을 리는 없다. 우리가 짜 놓은 다른 코드들을 실행할 수도 있고, 안드로이드라면 UI 애니메이션을 처리 할 수도 있다. 그러나 **Head는 어디선가 계속 그려지고 있다.** `drawHead()`는 2초가 걸리는 `suspend` 함수였음을 기억해 보자. `drawHead()`라는 `suspend`를 만나 코루틴을 탈출했지만, `drawHead()` 함수의 기능은 메인 스레드에서 동시성 프로그래밍으로 작동하고 있을 수도 있고, 다른 스레드에서 돌아가고 있을 수도 있다. 그것은 **개발자가 자유롭게 선택할 수 있다.**
4. 그렇게 메인 스레드가 다른 코드들을 실행하다가도, `drawHead()`가 제 역할을 다 끝내면 다시 아까 탈출했던 코루틴 `drawPerson()`으로 돌아온다. 아까 멈추어 놓았던 `drawHead()` 아래인 `drawBody()`부터 재개(resume)된다.

<br/>

위의 과정에서 보았듯이 코루틴 함수는 언제든지 나왔다가 다시 들어올 수 있다. 코루틴의 이런 성향은 동시성 프로그래밍과 밀접한 관계가 있다.

<br/>

### 동시성 프로그래밍 지원
함수를 중간에 빠져 나왔다가, 다른 함수에 진입하고, 다시 원점으로 돌아와 멈추었던 부분부터 다시 시작하는 이 특성은 동시성 프로그래밍을 가능하게 한다.  
동시성 프로그래밍은 병렬성 프로그래밍과 완전히 다른 개념이다.

<br/>

![https://user-images.githubusercontent.com/18481078/63692912-b9fe5280-c84d-11e9-9c8c-88b2bf5ade73.png](https://user-images.githubusercontent.com/18481078/63692912-b9fe5280-c84d-11e9-9c8c-88b2bf5ade73.png)

코루틴도 루틴이다. 즉, 스레드가 아니라 일반 서브 루틴과 비슷한 루틴이기 때문에 하나의 스레드에 여러 개가 존재할 수 있다.

<br/>

위의 코드에서는 메인 스레드에 코루틴이 두 개가 있다. 하나는 왼쪽 도화지에 그림을 그리는 코드고 다른 하나는 오른쪽 도화지에 그림을 그리는 코드다.  
메인 스레드가 실행되면서 먼저 왼쪽 코루틴인 `drawPersonToPaperA()`라는 함수를 만났다고 가정한다. 해당 함수는 가상 코루틴 빌더인 `startCoroutine {}` 블럭으로 인해 코루틴이 되고, 함수를 중간에 나갔다가 다시 들어올 수 있는 힘을 얻게 된다. `drawPersonToPaperA()`가 호출되어 `suspend`  함수인 `drawHead()`를 만나게 되면 이 코루틴을 잠시 빠져 나간다.

<br/>

왼쪽 코루틴을 빠져나갔지만 그렇다고 메인 스레드가 가만히 놀고 있진 않는다.  
다른 `suspend` 함수들을 찾거나 resume되어지는 다른 코드들을 찾는다. 왼쪽 코루틴의 경우 2초 동안 `drawHead()`  작업을 하게된다. 그러나 `delay(2000)`는 스레드를 블락시키지 않으므로 다른 일들을 할 수가 있다. 뿐만 아니라 `drawHead()`  함수 안에서 다른 스레드를 실행시킨다면 병행적으로도 실행이 가능하다. 왼쪽 코루틴을 빠져나온 스레드가 오른쪽 코루틴을 만나게 되어 또 한 번 `suspend`  함수를 만나게 되면 오른손에 펜을 쥐고 왼쪽과 오른쪽 도화지를 아주 빠르게 왔다 갔다 하면서 그림을 그리는 것 같이 된다. **이렇게 코루틴을 사용하여 스레드 하나에서 동시성 프로그래밍이 가능하다.**  

<br/>

코루틴을 생성해서 동시성 프로그래밍을 하는 것은, 스레드를 사용해서 동시성 프로그래밍을 하는 것과 차원이 다른 효율성을 제공한다. 위에서 말한 동작을 스레드 두 개를 만들어 실행한다고 가정한다.

<br/>

![https://user-images.githubusercontent.com/18481078/63693725-c7b4d780-c84f-11e9-9158-0d6b65c614fe.png](https://user-images.githubusercontent.com/18481078/63693725-c7b4d780-c84f-11e9-9158-0d6b65c614fe.png)

왼쪽 스레드는 왼쪽 도화지에, 오른쪽 스레드는 오른쪽 도화지에 그림을 그리는 스레드이다. 그러나 CPU는 단 한 개뿐이다. 따라서 왼쪽에 조금, 오른쪽에 조금을 반복하기 위해선 CPU가 매번 스레드를 점유했다가 놓아 주고, 새로운 스레드를 점유했다가 놓아 주고를 반복해야 한다. 이를 컨텍스트 스위칭이라고 한다. 하나의 스레드에서 단순히 함수를 왔다 갔다 하는 것과는 다르게 꽤 비용이 드는 작업이다.

<br/>

### 비동기 처리
위에서 설명한 코틀린의 능력으로 비동기 처리가 굉장히 쉬워진다. 심지어는 이게 비동기 처리인가? 싶을 정도로 읽기 쉽고 짜기도 쉬운 코드를 볼 수 있다.

<br/>
<br/>

# 🗂 참고
- [코틀린 코루틴(coroutine) 개념 익히기 · 쾌락코딩 (wooooooak.github.io)](https://wooooooak.github.io/kotlin/2019/08/25/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B0%9C%EB%85%90-%EC%9D%B5%ED%9E%88%EA%B8%B0/)
