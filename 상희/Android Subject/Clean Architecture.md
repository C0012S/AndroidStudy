# 💡 Clean Architecture

# ✅ Clean Architecture
## 클린 아키텍처(Clean Architecture)란?
클린 아키텍처는 『클린 코드(Clean Code)』를 저술한 로버트 마틴(Robert C. Martin)이 제안한 시스템 아키텍처로 기존의 계층형 아키텍처가 가지던 의존성에서 벗어나도록 하는 설계를 제공한다.  

<br/>

![https://image.toast.com/aaaadh/real/2022/techblog/01(2).png](https://image.toast.com/aaaadh/real/2022/techblog/01(2).png)

<br/>

이 원은 시스템을 구성하는 영역을 네 부분으로 나누고 있다.

<br/>

### 엔티티(Entities)
- 핵심 업무 규칙을 캡슐화한다.
- 메서드를 가지는 객체, 일련의 데이터 구조와 함수의 집합이다.
- 가장 변하지 않으며 외부로부터 영향을 받지 않는 영역이다.

<br/>

### 유즈 케이스(Use Cases)
- 애플리케이션의 특화된 업무 규칙을 포함한다.
- 시스템의 모든 유즈 케이스를 캡슐화하고 구현한다.
- 엔티티로 들어오고 나가는 데이터 흐름을 조정하고 조작한다.

<br/>

### 인터페이스 어댑터(Interface Adapter)
- 일련의 어댑터들로 구성한다.
- 외부 인터페이스에서 들어오는 데이터를 유즈 케이스와 엔티티에서 처리하기 편한 방식으로 변환하며, 유즈 케이스와 엔티티에서 나가는 데이터를 외부 인터페이스에서 처리하기 편한 방식으로 변환한다.
- 컨트롤러, 프레젠터, 게이트웨이 등이 여기에 속한다.

<br/>

### 프레임워크와 드라이버(Frameworks & Drivers)
- 시스템의 핵심 업무와는 관련 없는 세부 사항이다.
- 프레임워크나 데이터베이스, 웹 서버 등이 여기에 해당한다.

<br/>

이때 클린 아키텍처는 경계를 가장 중요하게 생각한다. 로버트 마틴은 경계에 대해 아래와 같이 설명한다.  
> 소프트웨어 아키텍처는 선을 긋는 기술이며, 나는 이러한 선을 경계(boundary)라고 부른다.
경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다. - Robert C. Martin, Clean Architecture
> 

<br/>

화살표의 방향은 의존성을 뜻한다. 클린 아키텍처의 의존성은 밖에서 안으로 향하고, 바깥 원은 안쪽 원에 영향을 미치지 않는다. 경계의 바깥으로 갈수록 덜 중요하고 세부적인 영역으로 표현되며 안으로 갈수록 고수준(좀 더 추상화된 개념)으로 표현된다.  
좀 더 풀어 설명하면 고수준이 ‘운동을 한다’ 라면, 저수준은 ‘집에서 팔벌려뛰기 운동을 한다’ 로 표현할 수 있다.  
잘 이해가 되지 않는다면 하나만 기억하면 된다. **바깥 원은 안쪽 원에 영향을 미치지 않는다!**

<br/>

## 클린 아키텍처(Clean Architecture)는 왜 필요할까?
어느 날 A 배달 앱이 B 배달 앱과 통합된다고 가정하고, 다음과 같은 요구를 받게 된다.  
*“A 배달 앱 시스템이 잘 되어 있으니 A 앱의 핵심 기능은 유지하고, UI와 DB 쪽만 바꿔 주세요.”*  
또는 다음과 같은 요구를 받을 수도 있다.  
*“A 배달 앱이 너무 잘되니 서비스를 웹으로 확장해 봅시다.”*  
비즈니스의 로직은 비슷한데, 변경해야 하는 부분도 많고, 아예 새로 만들 수도 없는 이러한 상황이라면 어떻게 할 것인가?

<br/>

만약 클린 아키텍처를 도입했다면, 단순하게 인터페이스 어댑터 영역과 프레임워크와 드라이브 영역만 수정하면 된다.  
왜냐하면 ‘고객과 업체 사이에서 배달 서비스를 중계한다’는 비즈니스 로직은 변하지 않았기 때문이다.  
이와 같이 클린 아키텍처는 비즈니스 로직은 바꾸지 않으면서, 언제든 DB와 프레임워크에 구애받지 않고 교체할 수 있는 아키텍처인 셈이다.

<br/>

## 클린 아키텍처(Clean Architecture)의 Android에서의 적용
![https://image.toast.com/aaaadh/real/2022/techblog/02(2).png](https://image.toast.com/aaaadh/real/2022/techblog/02(2).png)

<br/>

각 계층이 의미하는 바는 다음과 같다.  
### 프리젠테이션 계층(Presentation Layer)
- 뷰(View) : 직접적으로 플랫폼 의존적인 구현 즉, UI 화면 표시와 사용자 입력을 담당한다.
단순하게 프레젠터가 명령하는 일만 수행한다.
- 프레젠터(Presenter) : MVVM의 ViewModel과 같이 사용자 입력이 왔을 때 어떤 반응을 해야 하는지에 대한 판단을 하는 영역이다. 무엇을 그려야 할지도 알고 있는 영역이다.

<br/>

### 도메인 계층(Domain Layer)
- 유즈 케이스(Use Case) : 비즈니스 로직이 들어 있는 영역이다.
- 모델(Entity) : 앱의 실질적인 데이터이다.

<br/>

### 데이터 계층(Data Layer)
- 리포지터리(Repository) : 유즈 케이스가 필요로 하는 데이터의 저장 및 수정 등의 기능을 제공하는 영역으로, 데이터 소스를 인터페이스로 참조하여 로컬 DB와 네트워크 통신을 자유롭게 할 수 있다.
- 데이터 소스(Data Source) : 실제 데이터의 입출력이 여기서 실행된다.

<br/>

데이터의 흐름은 다음과 같다.  
![https://image.toast.com/aaaadh/real/2022/techblog/03(3).png](https://image.toast.com/aaaadh/real/2022/techblog/03(3).png)

<br/>

사용자의 인터렉션이 발생하면 이벤트는 위에서 아래로, 아래서 위로 흐른다.  
사용자가 버튼을 클릭하면 UI → 프레젠터 → 유즈 케이스 → 엔티티 → 리포지터리 → 데이터 소스로 이동하게 된다.

<br/>

위 흐름을 보면 다음과 같은 의문이 생길 수 있다.  
- 위 원에서 도메인 계층에 속해 있던 엔티티가 왜 데이터 계층에 있지?
- 트랜스레이터는 어디서 나왔지?
- 도메인 계층이 데이터 계층을 알고 있어야 데이터를 보낼 수 있는 게 아닌가?

<br/>

먼저, 데이터 계층의 엔티티는 위 원의 엔티티가 아니다.  
원의 엔티티는 도메인 계층의 모델이며 데이터 계층의 엔티티는 네트워크나 로컬 DB에서 받아온 DTO를 의미한다.  
따라서 계층을 횡단할 때 해당 계층에 맞게 변환해야 한다. 도메인 계층에서 모델이 트랜스레이터를 거쳐 데이터 계층의 엔티티로 변환되는 것이다. (이는 반대로도 가능하다.)  
또한 실제로 도메인 계층은 데이터 계층을 참고하고 있지 않는다. 그것은 바로 리포지터리에서 이루어지는 의존성 역전 법칙 때문이다.

<br/>

> 의존성 역전이란?  
객체 지향 프로그래밍에서 의존 관계 역전 원칙은 소프트웨어 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존 관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.
> 

<br/>

단순하게 말하면, 인터페이스로 만들고, 도메인 계층에서 인터페이스를 참조하면 된다.  
![https://image.toast.com/aaaadh/real/2022/techblog/04(3).png](https://image.toast.com/aaaadh/real/2022/techblog/04(3).png)

<br/>
<br/>

# 🗂 참고
- [[Android] 요즘 핫한 Clean Architecture 왜 쓰는 거야? : NHN Cloud Meetup](https://meetup.nhncloud.com/posts/345)
- [[Android] Clean Architecture 실전 압축 정리 - 개념 (tistory.com)](https://heegs.tistory.com/57)
- [안드로이드 Clean Architecture에 대하여 (velog.io)](https://velog.io/@squart300kg/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-Clean-Architecture%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)
